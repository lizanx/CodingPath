#include <iostream>

// Similar to copy ctor:
// If not explicitly defined or deleted, compiler will generate copy assignment operator for the class generally.
// (Except conditions such as the class has reference member/const member or non-copiable member)
// The implicitly generated copy assignment operator of derived class will call its base class's copy assignment operator automatically,
// no matter the copy assignment operator of base class is implicitly defined or user-defined.
// However, for any user-defined copy assignment operator, user must explicitly call base class's corresponding
// copy assignment operator to ensure correctness, since all behavior is user-defined and
// no "automatic call to base's copy assignment operator" is supplied by compiler.

class Base1
{
public:
    Base1(int data) : BaseData{data} {}
    // Implicit copy assignment operator generated by compiler
    int BaseData;
};

class Base2
{
public:
    Base2(int data) : BaseData{data} {}
    Base2 &operator=(const Base2 &other)
    {
        std::cout << "Base2::CopyAssign\n";
        BaseData = other.BaseData;
        return *this;
    }
    int BaseData;
};

class Derived1_1 : public Base1
{
public:
    Derived1_1(int baseData, int derivedData) : Base1{baseData}, DerivedData{derivedData} {}
    // Implicit copy assignment operator generated by compiler
    int DerivedData;
};

class Derived1_2 : public Base1
{
public:
    Derived1_2(int baseData, int derivedData) : Base1{baseData}, DerivedData{derivedData} {}
    Derived1_2 &operator=(const Derived1_2 &other)
    {
        std::cout << "Derived1_2::CopyAssign\n";
        Base1::operator=(other); // Call base class's copy assignment operator
        DerivedData = other.DerivedData;
        return *this;
    }
    int DerivedData;
};

class Derived2_1 : public Base2
{
public:
    Derived2_1(int baseData, int derivedData) : Base2{baseData}, DerivedData{derivedData} {}
    // Implicit copy assignment operator generated by compiler
    int DerivedData;
};

class Derived2_2 : public Base2
{
public:
    Derived2_2(int baseData, int derivedData) : Base2{baseData}, DerivedData{derivedData} {}
    Derived2_2 &operator=(const Derived2_2 &other)
    {
        std::cout << "Derived2_2::CopyAssign\n";
        Base2::operator=(other); // Call base class's copy assignment operator
        DerivedData = other.DerivedData;
        return *this;
    }
    int DerivedData;
};

int main(int argc, char *argv[])
{
    {
        std::cout << "=== Test Derived1_1 ===\n";
        Base1 b1{1};
        Derived1_1 d1{2, 3}, d2{4, 5};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // Compiler generated copy assignment.
        d2 = d1;
        std::cout << "After copy 'd2 = d1': "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // Compiler generated copy assignment for "Base1" - "Base1::operator=(const Base1&)", will copy only base part of d1(slicing)
        b1 = d1;
        std::cout << "After copy 'b1 = d1': "
                  << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Does not compile: no matching copy assignment operator "Derived1_1::operator=(const Base1&)"
        // d2 = b1;
    }

    {
        std::cout << "\n=== Test Derived1_2 ===\n";
        Base1 b1{1};
        Derived1_2 d1{2, 3}, d2{4, 5};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // User-defined copy assignment.
        d2 = d1;
        std::cout << "After copy 'd2 = d1': "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // Compiler generated copy assignment for "Base1" - "Base1::operator=(const Base1&)", will copy only base part of d1(slicing)
        b1 = d1;
        std::cout << "After copy 'b1 = d1': "
                  << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Does not compile: no matching copy assignment operator "Derived1_2::operator=(const Base1&)"
        // d2 = b1;
    }

    {
        std::cout << "\n=== Test Derived2_1 ===\n";
        Base2 b1{1};
        Derived2_1 d1{2, 3}, d2{4, 5};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // Compiler generated copy assignment.
        d2 = d1;
        std::cout << "After copy 'd2 = d1': "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // User-defined copy assignment for "Base2", depending on user-defined operations.
        b1 = d1;
        std::cout << "After copy 'b1 = d1': "
                  << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Does not compile: no matching copy assignment operator "Derived2_1::operator=(const Base2&)"
        // d2 = b1;
    }

    {
        std::cout << "\n=== Test Derived2_2 ===\n";
        Base2 b1{1};
        Derived2_2 d1{2, 3}, d2{4, 5};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // User-defined copy assignment.
        d2 = d1;
        std::cout << "After copy 'd2 = d1': "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "], "
                  << "d2[" << d2.BaseData << ", " << d2.DerivedData << "]\n";

        // User-defined copy assignment for "Base2", depending on user-defined operations.
        b1 = d1;
        std::cout << "After copy 'b1 = d1': "
                  << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Does not compile: no matching copy assignment operator "Derived2_2::operator=(const Base2&)"
        // d2 = b1;
    }
}

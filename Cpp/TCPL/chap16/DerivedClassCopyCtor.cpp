#include <iostream>

// If not explicitly defined or deleted, compiler will generate copy ctor for the class generally.
// (Except conditions such as the class has reference member/const member or non-copiable member)
// The implicitly generated copy ctor of derived class will call its base class's copy ctor automatically,
// no matter the copy ctor of base class is implicitly defined or user-defined.
// However, for any user-defined copy ctor, user must explicitly call base class's corresponding
// copy ctor to ensure correctness, since all behavior is user-defined and
// no "automatic call to base's copy ctor" is supplied by compiler.

class Base1
{
public:
    Base1(int data) : BaseData{data} {}
    // Implicit copy ctor generated by compiler
    int BaseData;
};

class Base2
{
public:
    Base2(int data) : BaseData{data} {}
    Base2(const Base2 &other) : Base2{other.BaseData}
    {
        std::cout << "Base2::CopyCtor\n";
    }
    int BaseData;
};

class Derived1_1 : public Base1
{
public:
    Derived1_1(int baseData, int derivedData) : Base1{baseData}, DerivedData{derivedData} {}
    // Implicit copy ctor generated by compiler
    int DerivedData;
};

class Derived1_2 : public Base1
{
public:
    Derived1_2(int baseData, int derivedData) : Base1{baseData}, DerivedData{derivedData} {}
    Derived1_2(const Derived1_2 &other) : Base1{other.BaseData}, DerivedData{other.DerivedData}
    {
        std::cout << "Derived1_2::CopyCtor\n";
    }
    int DerivedData;
};

class Derived2_1 : public Base2
{
public:
    Derived2_1(int baseData, int derivedData) : Base2{baseData}, DerivedData{derivedData} {}
    // Implicit copy ctor generated by compiler
    int DerivedData;
};

class Derived2_2 : public Base2
{
public:
    Derived2_2(int baseData, int derivedData) : Base2{baseData}, DerivedData{derivedData} {}
    Derived2_2(const Derived2_2 &other) : Base2{other}, DerivedData{other.DerivedData}
    {
        std::cout << "Derived2_2::CopyCtor\n";
    }
    int DerivedData;
};

int main(int argc, char *argv[])
{
    {
        std::cout << "=== Test Derived1_1 ===\n";
        Base1 b1{1};
        Derived1_1 d1{2, 3};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Compiler generated copy ctor for "Derived1_1", will copy base and derived data memberwise.
        Derived1_1 d2{d1};
        std::cout << "Copy constructed: d2[" << d2.BaseData << ", " << d1.DerivedData << "]\n";

        // Compiler generated copy ctor for "Base1" - "Base1::Base1(const Base1&)", will copy only base part of d1(slicing)
        Base1 b2{d1};
        std::cout << "Copy constructed: b2[" << b2.BaseData << "]\n";

        // Does not compile: no matching ctor "Derived1_1::Derived1_1(const Base1&)"
        // Derived1_1 d3{b1};
    }

    {
        std::cout << "\n=== Test Derived1_2 ===\n";
        Base1 b1{1};
        Derived1_2 d1{2, 3};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // User defined copy ctor for "Derived1_2", depending on user-defined operations.
        Derived1_2 d2{d1};
        std::cout << "Copy constructed: d2[" << d2.BaseData << ", " << d1.DerivedData << "]\n";

        // Compiler generated copy ctor for "Base1" - "Base1::Base1(const Base1&)", will copy only base part of d1(slicing)
        Base1 b2{d1};
        std::cout << "Copy constructed: b2[" << b2.BaseData << "]\n";

        // Does not compile: no matching ctor "Derived1_2::Derived1_2(const Base1&)"
        // Derived1_2 d3{b1};
    }

    {
        std::cout << "\n=== Test Derived2_1 ===\n";
        Base2 b1{1};
        Derived2_1 d1{2, 3};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // Compiler generated copy ctor for "Derived2_1", will call copy ctor of "Base2" implicitly.
        // Namely both "BaseData" and "DerivedData" will be copied.
        Derived2_1 d2{d1};
        std::cout << "Copy constructed: d2[" << d2.BaseData << ", " << d1.DerivedData << "]\n";

        // User defined copy ctor for "Base2", depending on user-defined operations.
        Base2 b2{d1};
        std::cout << "Copy constructed: b2[" << b2.BaseData << "]\n";

        // Does not compile: no matching ctor "Derived2_1::Derived2_1(const Base2&)"
        // Derived2_1 d3{b1};
    }

    {
        std::cout << "\n=== Test Derived2_2 ===\n";
        Base2 b1{1};
        Derived2_2 d1{2, 3};
        std::cout << "b1[" << b1.BaseData << "], "
                  << "d1[" << d1.BaseData << ", " << d1.DerivedData << "]\n";

        // User defined copy ctor for "Derived2_2", depending on user defined operations.
        // Won't call "Base2::Base2(const Base2&)" base copy ctor implicitly.
        Derived2_2 d2{d1};
        std::cout << "Copy constructed: d2[" << d2.BaseData << ", " << d1.DerivedData << "]\n";

        // User defined copy ctor for "Base2", depending on user-defined operations.
        Base2 b2{d1};
        std::cout << "Copy constructed: b2[" << b2.BaseData << "]\n";

        // Does not compile: no matching ctor "Derived2_2::Derived2_2(const Base2&)"
        // Derived2_2 d3{b1};
    }
}
